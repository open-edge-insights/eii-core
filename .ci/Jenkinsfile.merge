loadGlobalLibrary()

pipeline {
    agent { label 'EIS_Pipeline' }
    options {
        gitLabConnection('BuildAutomation')
        gitlabBuilds(builds: ['Checkout', 'Prepare', 'Pre-Receive', 'Build', 'Klocwork', 'Static Code Scan', 'Notify'])
        buildDiscarder(logRotator(numToKeepStr: '30', daysToKeepStr: '30'))
        timestamps()
        disableConcurrentBuilds()
        timeout(time: 6, unit: 'HOURS')
        skipDefaultCheckout() // manual checkout stage below to apply an actual merge
    }
    triggers {
        gitlab(
            triggerOnPush: false, // disable until ready
            triggerOnMergeRequest: false, // leave this false...otherwise causes to dobule trigger with `triggerOnPush`
            triggerOnNoteRequest: true,
            noteRegex: "Jenkins pipeline build",
            ciSkip: true,
            skipWorkInProgressMergeRequest: true,
            setBuildDescription: true,
            branchFilterType: "NameBasedFilter",
            includeBranchesSpec: "", //leave empty
            excludeBranchesSpec: ""  //leave empty
        )
    }
    environment {
        PASSWORD = credentials('eis-strong-password')
        STATIC_RESOURCES = "/home/$USER/openvino_sdk"
        OPENVINO_VERSION = "2020.1.023"
        EMAIL_ARTIFACTS_DIR = getTmpDir()
    }
    stages {
        stage('Checkout') {
            steps {
                script {
                    cloneSource()
                }
            }
        }

        stage('Prepare') {
            steps {
                //To remove all stopped containers and all untagged images
                sh '''
                set +e
                docker stop $(docker ps -a -q) && docker rm $(docker ps -a -q)
                docker rmi $(docker images | grep "^<none>" | awk "{print $3}")
                echo $PASSWORD | sudo -S rm -rf EIS-CI-Merge-Request_ws-cleanup*
                '''

                updateGitlabCommitStatus name: env.STAGE_NAME, state: 'success'
            }
        }

        // https://jenkins-iotg-ba.iind.intel.com/job/EIS-CI-Merge-Request/configure
        stage('Build') {
            steps {
                // Enable all services in build/docker-compose.yml
                echo "Uncomment all services in build/docker-compose.yml file..."
                sh 'sed -i "s:^  # :  :g" build/docker-compose.yml'

                dir('CITests') {
                    sh '''
                    echo $PASSWORD | sudo -SEH pip3 install -r requirements.txt
                    echo $PASSWORD | sudo -SE python3 pre_merge_and_nightly_build_script.py
                    '''
                    updateGitlabCommitStatus name: env.STAGE_NAME, state: 'success'
                }
            }
        }

        stage('Pre-Receive') {
            steps {
                dir('CITests') {
                    git url: 'ssh://git@gitlab.devtools.intel.com:29418/Indu/IEdgeInsights/CITests.git', changelog: false, poll: false
                }

                sh '''
                cp CITests/pre_receive_hook.sh .
                chmod +x pre_receive_hook.sh

                ./pre_receive_hook.sh GO_CHECK="no"
                '''

                updateGitlabCommitStatus name: env.STAGE_NAME, state: 'success'
            }
        }

        stage('Klocwork') {
            environment {
                STATIC_RESOURCES = "/home/$USER/openvino_sdk"
                OPENVINO_VERSION = "2020.1.023"
                PROJECT_NAME     = 'FoG_ETA'
                TABLE_ROOT       = "/home/$USER/kw/FG_Table"
                KW_SERVER        = 'https://klocwork-ir1.devtools.intel.com:8075'
                KW_HOST          = 'klocwork02p.elic.intel.com'
                KW_PORT          = '7500'
                KW_REPORT_QUERY  = "status:Analyze,Fix -status:'Fix in'" //taken from https://jenkins-iotg-val-ba.iind.intel.com/view/EIS/job/EIS_CI_NIGHTLY_Ubuntu_KW/configure
                PATH             = "$PATH:/home/$USER/kw/kw18/bin:/usr/local/go/bin"
                GOPATH           = "$WORKSPACE"
                RBHE_DOCKER      = credentials('intel-harbor-credentials')
            }
            steps {
                // modeled after https://jenkins-iotg-val-ba.iind.intel.com/view/EIS/job/EIS_CI_NIGHTLY_Docker_KW


                withCredentials([usernamePassword(credentialsId: 'eis-kw', usernameVariable: 'KW_USER', passwordVariable: 'KW_PWD')]) {
                    // available as an env variable, but will be masked if you try to print it out any which way
                    // note: single quotes prevent Groovy interpolation; expansion is by Bourne Shell, which is what you want
                    sh '''
                    echo $KW_USER > kwcreds
                    echo $KW_PWD >> kwcreds
                    '''
                }

                sh '''
                echo $PASSWORD | sudo -S chmod -R 777 docker_setup/provision
                cp -r CITests/klocwork/. .
                # Build klockwork image
                docker-compose build

                rm -rf kwcreds

                # Run KW scan
                docker-compose up -d

                # print logs
                docker logs -f ia_klocwork

                exit_code=`docker inspect ia_klocwork --format='{{.State.ExitCode}}'`
                if [ "$exit_code" != 0 ]; then
                    exit -1
                fi
                '''

                // generate KW report and archive
                script {
                    sh 'docker login --username="$RBHE_DOCKER_USR" --password="$RBHE_DOCKER_PSW" amr-registry.caas.intel.com'
                    sh 'docker pull amr-registry.caas.intel.com/rrp-devops/klocwork-report-agent:latest'

                    def kwReportImage = 'amr-registry.caas.intel.com/rrp-devops/klocwork-report-agent:latest'

                    docker.image(kwReportImage).inside('-v /home/labuser/.klocwork:/tmp/.klocwork -e http_proxy= -e https_proxy=') {
                        withEnv(['KLOCWORK_LTOKEN=/tmp/.klocwork/ltoken']) {
                            sh '''
                            mkdir -p klocwork-reports
                            python /klocwork/OWR_klocwork_report.py -s "https://irvapp007.ir.intel.com" -p "8075" -t "$PROJECT_NAME" -b default -q "$KW_REPORT_QUERY" -o klocwork-reports/kw_report.html
                            '''
                        }
                    }

                    publishHTML([
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: "klocwork-reports",
                        reportFiles: 'kw_report.html',
                        reportName: 'Klocwork Report',
                        reportTitles: 'Klocwork Report'
                    ])

                    archiveArtifacts allowEmptyArchive: true, artifacts: 'klocwork-reports/kw_report.csv'

                    sh 'mkdir -p $EMAIL_ARTIFACTS_DIR'
                    sh 'cp klocwork-reports/kw_report* $EMAIL_ARTIFACTS_DIR'
                }

                updateGitlabCommitStatus name: env.STAGE_NAME, state: 'success'
            }
        }

        stage('Checkmarx) {
            environment {
                SCANNERS = 'checkmarx'
                PROJECT_NAME = 'EIS'

                CHECKMARX_PROJECT_NAME     = 'IEI_CI_Checkmarx'
                CHECKMARX_CREDENTIAL_ID    = 'checkmarx-scanner-credentials'
                CHECKMARX_GROUP_ID         = '0f40ed7e-d5c7-45dd-ba72-a7a3ea9d59e5'
                CHECKMARX_PRESET_ID        = '100049'
                CHECKMARX_INCREMENTAL_SCAN = 'true'
            }
            steps {
                // need to scan a clean source code dir since the build script
                // dirties the workspace so much
                sh 'echo $PASSWORD | sudo -SE sudo rm -rf ${WORKSPACE}@[2,3,4]/*'
                sh 'echo $PASSWORD | sudo -SE sudo rm -rf ${WORKSPACE}@[2,3,4]/.[^.]*'

                dir('CleanSourceCode') {
                    script {
                        def gitVars = cloneSource()
                        def envVars = ["WORKSPACE=${WORKSPACE}/CleanSourceCode"]

                        if(env.gitlabSourceBranch) {
                            envVars << "GIT_BRANCH=${env.gitlabSourceBranch}"
                            envVars << "BRANCH_NAME=${env.gitlabSourceBranch}"
                            envVars << "GIT_COMMIT=${env.gitlabMergeRequestLastCommit}"
                            envVars << "SHORT_GIT_COMMIT=${env.gitlabMergeRequestLastCommit.substring(0,7)}"
                        } else {
                            gitVars.each { k, v ->
                                envVars << "${k}=${v}"
                            }
                        }

                        withEnv(envVars) {
                            rbheStaticCodeScan()
                        }
                    }
                }

                sh 'cp ${WORKSPACE}@[2,3,4]/**/**/CxSASTReport_* $EMAIL_ARTIFACTS_DIR/'

                updateGitlabCommitStatus name: env.STAGE_NAME, state: 'success'
            }
        }

        stage('Notify') {
            steps {
                sh 'rm -rf FinalReports && mkdir -p FinalReports'
                sh 'cp $EMAIL_ARTIFACTS_DIR/* FinalReports/'

                emailext(
                    body: '$DEFAULT_CONTENT',
                    replyTo: '$DEFAULT_REPLYTO',
                    subject: '$DEFAULT_SUBJECT',
                    to: env.EIS_BUILD_PDL,
                    attachmentsPattern: "FinalReports/*"
                )
            }
        }
    }
    post {
        success {
            updateGitlabCommitStatus name: 'Build', state: 'success'
        }

        failure {
            emailext(
                body: '$DEFAULT_CONTENT',
                replyTo: '$DEFAULT_REPLYTO',
                subject: '$DEFAULT_SUBJECT',
                to: env.EIS_BUILD_PDL
            )

            updateGitlabCommitStatus name: 'Build', state: 'failed'
        }
    }
}

def loadGlobalLibrary(branch = '*/master') {
    library(identifier: 'jenkins-common-pipelines@master',
        changelog: false,
        retriever: legacySCM([
            $class: 'GitSCM',
            branches: [[name: branch]],
            doGenerateSubmoduleConfigurations: false,
            userRemoteConfigs: [[
                credentialsId: 'iotg-rbhe-github-impcloud-pat',
                url: 'https://github.impcloud.net/Responsive-Retail/jenkins-common-pipelines.git'
            ]],
            extensions: [
                [$class: 'SubmoduleOption', recursiveSubmodules: true],
                [$class: 'IgnoreNotifyCommit']
            ]
        ])
    ) _
}

def cloneSource() {
    def gitVars

    if(env.gitlabSourceBranch && env.gitlabTargetBranch) {
        // https://github.com/jenkinsci/gitlab-plugin#pipeline-jobs
        gitVars = checkout( changelog: true,
            poll: false,
            scm: [
                $class: 'GitSCM',
                branches: [[ name: "origin/${env.gitlabSourceBranch}" ]],
                doGenerateSubmoduleConfigurations: false,
                extensions: [[ $class: 'PreBuildMerge', options: [fastForwardMode: 'FF', mergeRemote: 'origin', mergeStrategy: 'DEFAULT', mergeTarget: "${env.gitlabTargetBranch}"]]],
                submoduleCfg: [],
                userRemoteConfigs: [[ name: 'origin', url: scm.userRemoteConfigs.url[0], credentialsId: scm.userRemoteConfigs.credentialsId[0] ]]
        ])
    } else {
        gitVars = checkout scm
    }

    gitVars
}

def getTmpDir() {
    sh(script: 'mktemp -d -t ci-XXXXXXXXXX', returnStdout: true).trim()
}
